@page "/"
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject GlobalBool GlobalVariable
@inject GlobalSave GlobalSave
@inject GlobalPage GlobalPage
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime

@using System.Diagnostics;
@using Models.Battalions
@using Models.GlobalVariables;
@using Models.SaveState;
@using System.Reflection;
@using System.Timers;
@using RazorComponents;


<PageTitle>Kingdom</PageTitle>

<style>
    body {
        background-color: #e8fcee;
    }
     .progress-bar {
        width: 100%;
        background-color: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        height: 30px;
    }

    .progress-bar-fill {
        height: 100%;
        background-color: #76c7c0;
        width: 0%;
        transition: linear;
    }
</style>

@if (showModal) {
    <Modal Title="Greetings, choose your Title and Name" OnClose="HandleCloseModal" />
}

<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
    <div style="display: flex; flex-direction: column;">
        <h3 style="font-size: 25px; text-align: center; font-family: garamond, cursive;">@($"{GlobalSave.NewSave.PlayerInfo.KingdomName}")</h3>
        <h3 style="font-size: 18px; text-align: center; font-family: garamond, cursive;">@($"Owned by: {GlobalSave.NewSave.PlayerInfo.Title} {GlobalSave.NewSave.PlayerInfo.Name}")</h3>

         <img src="castleHighRes.png" alt="Ascii Castle" style="width: 100%; height: 360px;">
        
        <h3 style = "text-align: center;">Player Units</h3>
        <IdleGame.RazorComponents.UnitsRemaining Battalions="GlobalSave.NewSave.PlayerUnits"/> 
    </div>
    <div>
        <h3 style = "text-align: center;">Combat</h3>
        <IdleGame.RazorComponents.CombatComponent PlayerTotalHealth="playerTotalHealth" PlayerTotalMageOffence="playerTotalMageOffence" PlayerTotalMageDefence="playerTotalMageDefence" 
        PlayerTotalRangeOffence="playerTotalRangeOffence" PlayerTotalRangeDefence="playerTotalRangeDefence" PlayerTotalMeleeOffence="playerTotalMeleeOffence" playerTotalMeleeDefence="playerTotalMeleeDefence"
        EnemyTotalHealth ="enemyTotalHealth" EnemyTotalMageOffence="enemyTotalMageOffence" EnemyTotalMageDefence="enemyTotalMageDefence" EnemyTotalRangeOffence="enemyTotalRangeOffence"
        EnemyTotalRangeDefence="enemyTotalRangeDefence" EnemyTotalMeleeOffence="enemyTotalMeleeOffence" EnemyTotalMeleeDefence="enemyTotalMeleeDefence"
        />

        <div class="progress-bar">
    <div id="progressBarFill" class="progress-bar-fill"></div>
</div>

        <h3 style = "text-align: center;">Tank Order</h3>
        <div style="display: grid;">
            <IdleGame.RazorComponents.TankOrder PlayerBattalions="GlobalSave.NewSave.PlayerUnits" EnemyBattalions="GlobalSave.NewSave.EnemyUnits" />
            @* <div><div style="text-align: center;"><i class="fa-solid fa-crown" style="color: #dfbf4e;"></i> &nbsp;Player</div>
                <IdleGame.RazorComponents.TankOrderTesting IsPlayerUnit="true" Battalions="GlobalSave.NewSave.PlayerUnits"/>
            </div>
            <div><div style="text-align: center;"><i class="fa-solid fa-skull" style="color: #301012"></i> &nbsp;Enemy</div>
            <IdleGame.RazorComponents.TankOrderTesting Battalions="GlobalSave.NewSave.EnemyUnits" IsPlayerUnit="false"/>
            </div> *@
        </div>
    </div>
    <div>
        <img src="TrollWizardHighRes.png" alt="Ascii Troll" style="width: 100%; height: 360px;">
        <h3 style = "text-align: center;">Enemy Units</h3>
        <IdleGame.RazorComponents.UnitsRemaining Battalions="GlobalSave.NewSave.EnemyUnits"/>
    </div>
</div>
<div>@($"Clock Ticks: {clockTicks/5}")</div>

<button @onclick="BuildWizard">Wizard +5</button> 
<button @onclick="DeleteAllWizards">Delete Wizards</button> 
<button @onclick="KingdomCombat">@($"pDamage:{playerDamage}, eDamage:{enemyDamage}")</button>
<button @onclick="ResetFile">RESET FILE</button>
<button @onclick="Pause"> Pause Timer</button>
<button @onclick="ThreeSecondUnitUpdater">3 Second ++</button>
<button @onclick="DamageCalculator">@($"pDamage:{playerDamage}, eDamage:{enemyDamage}")</button>
<button @onclick="StartCombat">Start Combat</button>
<button @onclick="ProgressTimer">StopCombat</button>

@code {
    static double clockTicks;
    bool paused = false;
    bool showModal = false;
    bool shouldRender = true;
    int currentAnimation = 3;

    int currentTotalHealth = 0;
    int currentTotalMageOffence = 0;
    int currentTotalMageDefence = 0;
    int currentTotalRangeOffence = 0;
    int currentTotalRangeDefence = 0;
    int currentTotalMeleeOffence = 0;
    int currentTotalMeleeDefence = 0;
    static int playerTotalHealth = 0;
    static int playerTotalMageOffence = 0;
    static int playerTotalMageDefence = 0;
    static int playerTotalRangeOffence = 0;
    static int playerTotalRangeDefence = 0;
    static int playerTotalMeleeOffence = 0;
    static int playerTotalMeleeDefence = 0;
    static int enemyTotalHealth = 0;
    static int enemyTotalMageOffence = 0;
    static int enemyTotalMageDefence = 0;
    static int enemyTotalRangeOffence = 0;
    static int enemyTotalRangeDefence = 0;
    static int enemyTotalMeleeOffence = 0;
    static int enemyTotalMeleeDefence = 0;
    static long playerDamage = 0;
    static long enemyDamage = 0;

    
    protected override async Task OnInitializedAsync(){
        GlobalSave.OnPlayerUnitsChanged += StatUpdater;

        if (GlobalBool.TimerStarted == false){
            GlobalSave.NewSave = new TutorialSave();
        }
        GlobalPage.PageNumber = 1;

         if (await localStorage.GetItemAsync<EmptySave>("saveState") == null){
            await localStorage.SetItemAsync<EmptySave>("saveState", GlobalSave.NewSave);
            showModal = true;
            GlobalSave.NewSave = await localStorage.GetItemAsync<EmptySave>("saveState");
        }
        else {
            GlobalSave.NewSave = await localStorage.GetItemAsync<EmptySave>("saveState");
            StatUpdater();
        }

        if (GlobalBool.TimerStarted == false){
            GlobalVariable.FirstRender = false;
            GlobalBool.TimerStarted = true;
            await JSRuntime.InvokeVoidAsync("timerWorker.resourceStart");
            await JSRuntime.InvokeVoidAsync("timerWorker.kingdomCombatStart");
            await StartCombat();
            GlobalSave.OnTimeChanged += SaveLocalStorage;
            GlobalSave.OnKingdomCombat += ProgressTimer;

        }

    }

     private async Task StartCombat() {
        await JSRuntime.InvokeVoidAsync("timerWorker.kingdomCombatStart");
        await JSRuntime.InvokeVoidAsync("startGameLoop");
    }

    private async void ProgressTimer() {
        await JSRuntime.InvokeVoidAsync("stopGameLoop");
        await JSRuntime.InvokeVoidAsync("startGameLoop");
        Console.WriteLine("Progress Timer Called");
    }

    public async Task ThreeSecondUnitUpdater(){
        await Task.Delay(3000);
        GlobalSave.NewSave.PlayerUnits.Wizards.Count ++;
        GlobalSave.NotifyPlayerUnitsChanged();
    }
    
    [JSInvokable]
    public static async Task OnResourceTick() {
        clockTicks ++;
        GlobalSave.NotifyTimeChanged();
        await Task.CompletedTask;
    }
    [JSInvokable]
    public static async Task OnKingdomCombatTick() {
        //await KingdomCombat();                                //Turn on or off combat
        GlobalSave.NotifyKingdomCombat();
        await Task.CompletedTask;
        GlobalSave.NotifyPlayerUnitsChanged();
        
    }

    // Currently responsible for using javascript web worker to save current save to local storage
    private void SaveLocalStorage() {
        localStorage.SetItemAsync<EmptySave>("saveState", GlobalSave.NewSave);
        InvokeAsync(StateHasChanged);
    }
    @* [JSInvokable] *@
    public async Task Dispose() {
        await JSRuntime.InvokeVoidAsync("timerWorker.resourceStop");
        await JSRuntime.InvokeVoidAsync("timerWorker.kingdomCombatStop");
    }
    [JSInvokable]
    public async Task JsTimerStart() {
        await JSRuntime.InvokeVoidAsync("timerWorker.resourceStart");
        await JSRuntime.InvokeVoidAsync("timerWorker.kingdomCombatStart");
    }
    public async Task Pause() {
        if (paused == true) {
            await JsTimerStart();
            paused = false;
        }
        else {
            await Dispose();
             paused = true;
        }
    }
    public async Task ResetFile() {
        await localStorage.RemoveItemAsync("saveState");
        NavManager.NavigateTo("/", forceLoad:true); // reloads the page so that creation of a new character can trigger *@
        await InvokeAsync(StateHasChanged);
    }
    public void ProcessBattle(object battalions) {
        int totalHealth = 0;
        int totalMageOffence = 0;
        int totalMageDefence = 0;
        int totalRangeOffence = 0;
        int totalRangeDefence = 0;
        int totalMeleeOffence = 0;
        int totalMeleeDefence = 0;
        
        foreach (PropertyInfo unit in battalions.GetType().GetProperties()){
            var unitCount = unit.GetValue(battalions);
            if (unitCount != null){
                var unitProperty = unitCount.GetType().GetProperty("Unit");
                var countProperty = unitCount.GetType().GetProperty("Count");
                var hpProperty = unitCount.GetType().GetProperty("HP");
                if (unitProperty != null){
                    var unitInstance = unitProperty.GetValue(unitCount);
                    var numUnits = countProperty.GetValue(unitCount);
                    var unitHp = hpProperty.GetValue(unitCount);
                    foreach (var property in unitInstance.GetType().GetProperties()){

                    // Add each unit's property values to the corresponding totals
                    switch (property.Name) {
                        case "Health":
                            totalHealth += (((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits)) - ((int)property.GetValue(unitInstance) - (int)unitHp));
                            break;
                        case "MagicOffence":
                            totalMageOffence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        case "MagicDefence":
                            totalMageDefence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        case "RangeOffence":
                            totalRangeOffence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        case "RangeDefence":
                            totalRangeDefence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        case "MeleeOffence":
                            totalMeleeOffence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        case "MeleeDefence":
                            totalMeleeDefence += ((int)property.GetValue(unitInstance) * Convert.ToInt32(numUnits));
                            break;
                        default:
                    break;
                    }

                    }
                }
            }
        }
        currentTotalHealth = totalHealth;
        currentTotalMageOffence = totalMageOffence;
        currentTotalMageDefence = totalMageDefence;
        currentTotalRangeOffence = totalRangeOffence;
        currentTotalRangeDefence = totalRangeDefence;
        currentTotalMeleeOffence = totalMeleeOffence;
        currentTotalMeleeDefence = totalMeleeDefence;
    }

    // Combat calculator to handle player kingdom under siege
    public void StatUpdater() {
        // Collect total stats for player character
        ProcessBattle(GlobalSave.NewSave.PlayerUnits);

        // Create variable to hold all of the current player stats
        playerTotalHealth = currentTotalHealth;
        playerTotalMageOffence = currentTotalMageOffence;
        playerTotalMageDefence = currentTotalMageDefence;
        playerTotalRangeOffence = currentTotalRangeOffence;
        playerTotalRangeDefence = currentTotalRangeDefence;
        playerTotalMeleeOffence = currentTotalMeleeOffence;
        playerTotalMeleeDefence = currentTotalMeleeDefence;
        
        // Collect total stats for enemy character
        ProcessBattle(GlobalSave.NewSave.EnemyUnits);

        // Create variable to hold all of the current enemy stats
        enemyTotalHealth = currentTotalHealth;
        enemyTotalMageOffence = currentTotalMageOffence;
        enemyTotalMageDefence = currentTotalMageDefence;
        enemyTotalRangeOffence = currentTotalRangeOffence;
        enemyTotalRangeDefence = currentTotalRangeDefence;
        enemyTotalMeleeOffence = currentTotalMeleeOffence;
        enemyTotalMeleeDefence = currentTotalMeleeDefence;

        // Update the ui to reflect changes
        InvokeAsync(StateHasChanged);
    }
    public static async Task DamageCalculator() {
        playerDamage = 0;
        enemyDamage = 0;    
        // Determine player's damage
        if (playerTotalMageOffence <= enemyTotalMageDefence) {
            double mageRatio = 0;
            
            mageRatio = Math.Round((double)playerTotalMageOffence/enemyTotalMageDefence, 3);
            playerDamage += (int)(playerTotalMageOffence * mageRatio);

        }
        else {
            double mageRatio = Math.Log((playerTotalMageOffence - enemyTotalMageDefence), 10);
            if (mageRatio > 1){
                 playerDamage += (int)(playerTotalMageOffence*mageRatio);
            }
            else {
                playerDamage += playerTotalMageOffence;
            }
        }

        if (playerTotalRangeOffence <= enemyTotalRangeDefence) {
            double rangeRatio = 0;
            
            rangeRatio = Math.Round((double)playerTotalRangeOffence/enemyTotalRangeDefence, 3);
            playerDamage += (int)(playerTotalRangeOffence * rangeRatio);

        }
        else {
            double rangeRatio = Math.Log((playerTotalRangeOffence - enemyTotalRangeDefence), 10);
            if (rangeRatio > 1){
                playerDamage += (int)(playerTotalRangeOffence*rangeRatio);
            }
            else {
                playerDamage += playerTotalRangeOffence;
            }
        }

        if (playerTotalMeleeOffence <= enemyTotalMeleeDefence) {
            double meleeRatio = 0;
            
            meleeRatio = Math.Round((double)playerTotalMeleeOffence/enemyTotalMeleeDefence, 3);
            playerDamage += (int)(playerTotalMeleeOffence * meleeRatio);

        }
        else {
            double meleeRatio = Math.Log((playerTotalMeleeOffence - enemyTotalMeleeDefence), 10);
            if (meleeRatio > 1){
                playerDamage += (int)(playerTotalMeleeOffence*meleeRatio);
            }
            else {
                playerDamage += playerTotalMeleeOffence;
            }
        }

        // Determine enemy's damage
        if (enemyTotalMageOffence <= playerTotalMageDefence) {
            double mageRatio = 0;
            
            mageRatio = Math.Round((double)enemyTotalMageOffence/playerTotalMageDefence, 3);
            enemyDamage += (int)(enemyTotalMageOffence * mageRatio);

        }
        else {
            double mageRatio = Math.Log((enemyTotalMageOffence - playerTotalMageDefence), 10);
            if (mageRatio > 1){
                enemyDamage += (int)(enemyTotalMageOffence*mageRatio);
            }
            else {
                enemyDamage += enemyTotalMageOffence;
            }
        }

        if (enemyTotalRangeOffence <= playerTotalRangeDefence) {
            double rangeRatio = 0;
            
            rangeRatio = Math.Round((double)enemyTotalRangeOffence/playerTotalRangeDefence, 3);
            enemyDamage += (int)(enemyTotalRangeOffence * rangeRatio);

        }
        else {
            double rangeRatio = Math.Log((enemyTotalRangeOffence - playerTotalRangeDefence), 10);
            if (rangeRatio > 1){
                 enemyDamage += (int)(enemyTotalRangeOffence*rangeRatio);
            }
            else {
                enemyDamage += enemyTotalMeleeOffence;
            }
        }

        if (enemyTotalMeleeOffence <= playerTotalMeleeDefence) {
            double meleeRatio = 0;
            
            meleeRatio = Math.Round((double)enemyTotalMeleeOffence/playerTotalMeleeDefence, 3);
            enemyDamage += (int)(enemyTotalMeleeOffence * meleeRatio);

        }
        else {
            double meleeRatio = Math.Log((enemyTotalMeleeOffence - playerTotalMeleeDefence), 10);
            if (meleeRatio >1){
                enemyDamage += (int)(enemyTotalMeleeOffence*meleeRatio);
            }
            else {
                enemyDamage += enemyTotalMeleeOffence;
            }

        }
    }

    public static async Task DamageUpdater(object battalions, bool isPlayer) {
    // Calculate how much damage the player and enemy will do to each other

    // Create a list to hold units with Count > 0
    var unitsList = new List<object>();

    // Collect the units with Count > 0
    foreach (PropertyInfo unit in battalions.GetType().GetProperties()) {
        var thisUnit = unit.GetValue(battalions);
        if (thisUnit != null) {
            var unitProperty = thisUnit.GetType().GetProperty("Unit");
            var countProperty = thisUnit.GetType().GetProperty("Count");
            var numUnits = (int?)countProperty?.GetValue(thisUnit);

            if (numUnits > 0) {
                unitsList.Add(thisUnit);
            }
        }
    }

    // Sort the list by TankOrder
    unitsList.Sort((unit1, unit2) => {
        var tankOrder1 = (int?)unit1.GetType().GetProperty("Unit")?.GetValue(unit1)?.GetType().GetProperty("TankOrder")?.GetValue(unit1.GetType().GetProperty("Unit")?.GetValue(unit1));
        var tankOrder2 = (int?)unit2.GetType().GetProperty("Unit")?.GetValue(unit2)?.GetType().GetProperty("TankOrder")?.GetValue(unit2.GetType().GetProperty("Unit")?.GetValue(unit2));
        return tankOrder1.GetValueOrDefault().CompareTo(tankOrder2.GetValueOrDefault());
    });

    double? maxDamage;
    double? remainingDamage;

    // Apply the damage
    if (isPlayer){
        maxDamage = enemyDamage;
        remainingDamage = enemyDamage;
    }
    else {
        maxDamage = playerDamage;
        remainingDamage = playerDamage;
    }
    int count = 0;

    foreach (var unit in unitsList) {

        // Used to check if the unit is the last unit in the list, and if so apply the remaining damage to it
        count ++;

        var unitInstance = unit.GetType().GetProperty("Unit")?.GetValue(unit);
        var countProperty = unit.GetType().GetProperty("Count");
        var hpProperty = unit.GetType().GetProperty("HP");

        var numUnits = (int?)countProperty?.GetValue(unit);
        var healthProperty = unitInstance?.GetType().GetProperty("Health");
        var tankEffectivenessProperty = unitInstance?.GetType().GetProperty("TankEffectiveness");

        var unitHealth = (int?)healthProperty?.GetValue(unitInstance);
        var unitHP = (int?)hpProperty?.GetValue(unit);
        var tankEffectiveness = (double?)tankEffectivenessProperty?.GetValue(unitInstance);

        if (count != unitsList.Count){
            maxDamage = remainingDamage * tankEffectiveness.GetValueOrDefault();
            remainingDamage -= maxDamage;
        }
        else {
            maxDamage = remainingDamage;
        }

        // Checks if the damage being done to the current unit would exceed a single units HP, and if its HP was currently less than max
        if (maxDamage >= unitHP){
            maxDamage -= (double)unitHP;
            unitHP = unitHealth;
            numUnits --;
        }
        else {
            unitHP -= (int)maxDamage;
            hpProperty?.SetValue(unit, unitHP);
            continue;
        }

        if (numUnits > 0){
            int? totalHp = unitHealth * numUnits;
            if (maxDamage >= totalHp) {
                remainingDamage += (maxDamage - totalHp);
                numUnits = 0;
            }
            else {
                int? unitsKilled = (int)maxDamage / unitHealth;
                int? excessDamage = (int)maxDamage % unitHealth;
                numUnits -= unitsKilled;
                unitHP -= excessDamage;
            }
        }
        countProperty?.SetValue(unit, numUnits);
        hpProperty?.SetValue(unit, unitHP);
    }
}

    private static async Task KingdomCombat() {
        GlobalSave.NotifyPlayerUnitsChanged();
        await DamageCalculator();
        await DamageUpdater(GlobalSave.NewSave.PlayerUnits, true);
        await DamageUpdater(GlobalSave.NewSave.EnemyUnits, false);
    }

    public void BuildWizard() {
        GlobalSave.NewSave.PlayerUnits.Wizards.Count += 5;
        GlobalSave.NotifyPlayerUnitsChanged();
        foreach (PropertyInfo prop in typeof(PlayerBattalions).GetProperties()){
            var unitCount = prop.GetValue(GlobalSave.NewSave.PlayerUnits);
            if (unitCount != null){
                PropertyInfo countProp = unitCount.GetType().GetProperty("Count");
                if (countProp != null){
                    int? count = (int?)countProp.GetValue(unitCount);
                    Console.WriteLine($"{prop.Name}: {count}");
                }
            }
            
        }
    
    }

    public void DeleteAllWizards() {
        GlobalSave.NewSave.PlayerUnits.Wizards.Count = 0;
        GlobalSave.NotifyPlayerUnitsChanged();
    }
     private async Task HandleSubmit(string titleAndName)
    {
        showModal = false;
        // You can use the titleAndName value here
        await Task.CompletedTask;
    }

    void ToggleModal()
    {
        showModal = !showModal;
    }
    void HandleCloseModal()
    {
        showModal = false; // Update the showModal variable to close the modal
    }
}
